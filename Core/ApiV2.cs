// Copyright 2015 ThoughtWorks, Inc.

// This file is part of Gauge-CSharp.

// Gauge-CSharp is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Gauge-CSharp is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Gauge-CSharp.  If not, see <http://www.gnu.org/licenses/>.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api_v2.proto
// Original file comments:

#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Gauge.Messages {

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class ApiV2 {

    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_gauge_messages_ExecutionRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.ExecutionRequest, global::Gauge.Messages.ExecutionRequest.Builder> internal__static_gauge_messages_ExecutionRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_gauge_messages_Result__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.Result, global::Gauge.Messages.Result.Builder> internal__static_gauge_messages_Result__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_gauge_messages_Result_ExecutionError__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.Result.Types.ExecutionError, global::Gauge.Messages.Result.Types.ExecutionError.Builder> internal__static_gauge_messages_Result_ExecutionError__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_gauge_messages_ExecutionResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.ExecutionResponse, global::Gauge.Messages.ExecutionResponse.Builder> internal__static_gauge_messages_ExecutionResponse__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;

    static ApiV2() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgxhcGlfdjIucHJvdG8SDmdhdWdlLm1lc3NhZ2VzIoEDChBFeGVjdXRpb25S", 
            "ZXF1ZXN0Eg0KBXNwZWNzGAEgAygJEgwKBHRhZ3MYAiABKAkSEgoKd29ya2lu", 
            "Z0RpchgDIAEoCRILCgNlbnYYBCABKAkSOwoIbG9nTGV2ZWwYBSABKA4yKS5n", 
            "YXVnZS5tZXNzYWdlcy5FeGVjdXRpb25SZXF1ZXN0LkxvZ0xldmVsEhIKCmlz", 
            "UGFyYWxsZWwYBiABKAgSFwoPcGFyYWxsZWxTdHJlYW1zGAcgASgFEgwKBHNv", 
            "cnQYCCABKAgSOwoIc3RyYXRlZ3kYCSABKA4yKS5nYXVnZS5tZXNzYWdlcy5F", 
            "eGVjdXRpb25SZXF1ZXN0LlN0cmF0ZWd5EhEKCXRhYmxlUm93cxgKIAEoCRIN", 
            "CgVkZWJ1ZxgLIAEoCCI3CghMb2dMZXZlbBIICgRJTkZPEAASCQoFREVCVUcQ", 
            "ARILCgdXQVJOSU5HEAISCQoFRVJST1IQAyIfCghTdHJhdGVneRIICgRMQVpZ", 
            "EAASCQoFRUFHRVIQASKvAwoGUmVzdWx0Ei0KBnN0YXR1cxgBIAEoDjIdLmdh", 
            "dWdlLm1lc3NhZ2VzLlJlc3VsdC5TdGF0dXMSNQoGZXJyb3JzGAIgAygLMiUu", 
            "Z2F1Z2UubWVzc2FnZXMuUmVzdWx0LkV4ZWN1dGlvbkVycm9yEhUKDWV4ZWN1", 
            "dGlvblRpbWUYAyABKAMSDgoGc3Rkb3V0GAQgASgJEkAKEWJlZm9yZUhvb2tG", 
            "YWlsdXJlGAUgASgLMiUuZ2F1Z2UubWVzc2FnZXMuUmVzdWx0LkV4ZWN1dGlv", 
            "bkVycm9yEj8KEGFmdGVySG9va0ZhaWx1cmUYBiABKAsyJS5nYXVnZS5tZXNz", 
            "YWdlcy5SZXN1bHQuRXhlY3V0aW9uRXJyb3ISFgoOdGFibGVSb3dOdW1iZXIY", 
            "ByABKAMaTgoORXhlY3V0aW9uRXJyb3ISFAoMZXJyb3JNZXNzYWdlGAEgASgJ", 
            "EhIKCnN0YWNrVHJhY2UYAiABKAkSEgoKc2NyZWVuc2hvdBgDIAEoDCItCgZT", 
            "dGF0dXMSCgoGUEFTU0VEEAASCgoGRkFJTEVEEAESCwoHU0tJUFBFRBACIvQB", 
            "ChFFeGVjdXRpb25SZXNwb25zZRI0CgR0eXBlGAEgAigOMiYuZ2F1Z2UubWVz", 
            "c2FnZXMuRXhlY3V0aW9uUmVzcG9uc2UuVHlwZRIKCgJJRBgCIAEoCRImCgZy", 
            "ZXN1bHQYAyABKAsyFi5nYXVnZS5tZXNzYWdlcy5SZXN1bHQidQoEVHlwZRIO", 
            "CgpTdWl0ZVN0YXJ0EAASDQoJU3BlY1N0YXJ0EAESEQoNU2NlbmFyaW9TdGFy", 
            "dBACEg8KC1NjZW5hcmlvRW5kEAMSCwoHU3BlY0VuZBAEEgwKCFN1aXRlRW5k", 
            "EAUSDwoLRXJyb3JSZXN1bHQQBjJfCglFeGVjdXRpb24SUgoHZXhlY3V0ZRIg", 
            "LmdhdWdlLm1lc3NhZ2VzLkV4ZWN1dGlvblJlcXVlc3QaIS5nYXVnZS5tZXNz", 
          "YWdlcy5FeGVjdXRpb25SZXNwb25zZSIAMAFCEaoCDkdhdWdlLk1lc3NhZ2Vz"));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_gauge_messages_ExecutionRequest__Descriptor = Descriptor.MessageTypes[0];
        internal__static_gauge_messages_ExecutionRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.ExecutionRequest, global::Gauge.Messages.ExecutionRequest.Builder>(internal__static_gauge_messages_ExecutionRequest__Descriptor,
                new string[] { "Specs", "Tags", "WorkingDir", "Env", "LogLevel", "IsParallel", "ParallelStreams", "Sort", "Strategy", "TableRows", "Debug", });
        internal__static_gauge_messages_Result__Descriptor = Descriptor.MessageTypes[1];
        internal__static_gauge_messages_Result__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.Result, global::Gauge.Messages.Result.Builder>(internal__static_gauge_messages_Result__Descriptor,
                new string[] { "Status", "Errors", "ExecutionTime", "Stdout", "BeforeHookFailure", "AfterHookFailure", "TableRowNumber", });
        internal__static_gauge_messages_Result_ExecutionError__Descriptor = internal__static_gauge_messages_Result__Descriptor.NestedTypes[0];
        internal__static_gauge_messages_Result_ExecutionError__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.Result.Types.ExecutionError, global::Gauge.Messages.Result.Types.ExecutionError.Builder>(internal__static_gauge_messages_Result_ExecutionError__Descriptor,
                new string[] { "ErrorMessage", "StackTrace", "Screenshot", });
        internal__static_gauge_messages_ExecutionResponse__Descriptor = Descriptor.MessageTypes[2];
        internal__static_gauge_messages_ExecutionResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gauge.Messages.ExecutionResponse, global::Gauge.Messages.ExecutionResponse.Builder>(internal__static_gauge_messages_ExecutionResponse__Descriptor,
                new string[] { "Type", "ID", "Result", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion

  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ExecutionRequest : pb::GeneratedMessage<ExecutionRequest, ExecutionRequest.Builder> {
    private ExecutionRequest() { }
    private static readonly ExecutionRequest defaultInstance = new ExecutionRequest().MakeReadOnly();
    private static readonly string[] _executionRequestFieldNames = new string[] { "debug", "env", "isParallel", "logLevel", "parallelStreams", "sort", "specs", "strategy", "tableRows", "tags", "workingDir" };
    private static readonly uint[] _executionRequestFieldTags = new uint[] { 88, 34, 48, 40, 56, 64, 10, 72, 82, 18, 26 };
    public static ExecutionRequest DefaultInstance {
      get { return defaultInstance; }
    }

    public override ExecutionRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }

    protected override ExecutionRequest ThisMessage {
      get { return this; }
    }

    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_ExecutionRequest__Descriptor; }
    }

    protected override pb::FieldAccess.FieldAccessorTable<ExecutionRequest, ExecutionRequest.Builder> InternalFieldAccessors {
      get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_ExecutionRequest__FieldAccessorTable; }
    }

    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum LogLevel {
        INFO = 0,
        DEBUG = 1,
        WARNING = 2,
        ERROR = 3,
      }

      public enum Strategy {
        LAZY = 0,
        EAGER = 1,
      }

    }
    #endregion

    public const int SpecsFieldNumber = 1;
    private pbc::PopsicleList<string> specs_ = new pbc::PopsicleList<string>();
    public scg::IList<string> SpecsList {
      get { return pbc::Lists.AsReadOnly(specs_); }
    }
    public int SpecsCount {
      get { return specs_.Count; }
    }
    public string GetSpecs(int index) {
      return specs_[index];
    }

    public const int TagsFieldNumber = 2;
    private bool hasTags;
    private string tags_ = "";
    public bool HasTags {
      get { return hasTags; }
    }
    public string Tags {
      get { return tags_; }
    }

    public const int WorkingDirFieldNumber = 3;
    private bool hasWorkingDir;
    private string workingDir_ = "";
    public bool HasWorkingDir {
      get { return hasWorkingDir; }
    }
    public string WorkingDir {
      get { return workingDir_; }
    }

    public const int EnvFieldNumber = 4;
    private bool hasEnv;
    private string env_ = "";
    public bool HasEnv {
      get { return hasEnv; }
    }
    public string Env {
      get { return env_; }
    }

    public const int LogLevelFieldNumber = 5;
    private bool hasLogLevel;
    private global::Gauge.Messages.ExecutionRequest.Types.LogLevel logLevel_ = global::Gauge.Messages.ExecutionRequest.Types.LogLevel.INFO;
    public bool HasLogLevel {
      get { return hasLogLevel; }
    }
    public global::Gauge.Messages.ExecutionRequest.Types.LogLevel LogLevel {
      get { return logLevel_; }
    }

    public const int IsParallelFieldNumber = 6;
    private bool hasIsParallel;
    private bool isParallel_;
    public bool HasIsParallel {
      get { return hasIsParallel; }
    }
    public bool IsParallel {
      get { return isParallel_; }
    }

    public const int ParallelStreamsFieldNumber = 7;
    private bool hasParallelStreams;
    private int parallelStreams_;
    public bool HasParallelStreams {
      get { return hasParallelStreams; }
    }
    public int ParallelStreams {
      get { return parallelStreams_; }
    }

    public const int SortFieldNumber = 8;
    private bool hasSort;
    private bool sort_;
    public bool HasSort {
      get { return hasSort; }
    }
    public bool Sort {
      get { return sort_; }
    }

    public const int StrategyFieldNumber = 9;
    private bool hasStrategy;
    private global::Gauge.Messages.ExecutionRequest.Types.Strategy strategy_ = global::Gauge.Messages.ExecutionRequest.Types.Strategy.LAZY;
    public bool HasStrategy {
      get { return hasStrategy; }
    }
    public global::Gauge.Messages.ExecutionRequest.Types.Strategy Strategy {
      get { return strategy_; }
    }

    public const int TableRowsFieldNumber = 10;
    private bool hasTableRows;
    private string tableRows_ = "";
    public bool HasTableRows {
      get { return hasTableRows; }
    }
    public string TableRows {
      get { return tableRows_; }
    }

    public const int DebugFieldNumber = 11;
    private bool hasDebug;
    private bool debug_;
    public bool HasDebug {
      get { return hasDebug; }
    }
    public bool Debug {
      get { return debug_; }
    }

    public override bool IsInitialized {
      get {
        return true;
      }
    }

    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _executionRequestFieldNames;
      if (specs_.Count > 0) {
        output.WriteStringArray(1, field_names[6], specs_);
      }
      if (hasTags) {
        output.WriteString(2, field_names[9], Tags);
      }
      if (hasWorkingDir) {
        output.WriteString(3, field_names[10], WorkingDir);
      }
      if (hasEnv) {
        output.WriteString(4, field_names[1], Env);
      }
      if (hasLogLevel) {
        output.WriteEnum(5, field_names[3], (int) LogLevel, LogLevel);
      }
      if (hasIsParallel) {
        output.WriteBool(6, field_names[2], IsParallel);
      }
      if (hasParallelStreams) {
        output.WriteInt32(7, field_names[4], ParallelStreams);
      }
      if (hasSort) {
        output.WriteBool(8, field_names[5], Sort);
      }
      if (hasStrategy) {
        output.WriteEnum(9, field_names[7], (int) Strategy, Strategy);
      }
      if (hasTableRows) {
        output.WriteString(10, field_names[8], TableRows);
      }
      if (hasDebug) {
        output.WriteBool(11, field_names[0], Debug);
      }
      UnknownFields.WriteTo(output);
    }

    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }

    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        foreach (string element in SpecsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * specs_.Count;
      }
      if (hasTags) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Tags);
      }
      if (hasWorkingDir) {
        size += pb::CodedOutputStream.ComputeStringSize(3, WorkingDir);
      }
      if (hasEnv) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Env);
      }
      if (hasLogLevel) {
        size += pb::CodedOutputStream.ComputeEnumSize(5, (int) LogLevel);
      }
      if (hasIsParallel) {
        size += pb::CodedOutputStream.ComputeBoolSize(6, IsParallel);
      }
      if (hasParallelStreams) {
        size += pb::CodedOutputStream.ComputeInt32Size(7, ParallelStreams);
      }
      if (hasSort) {
        size += pb::CodedOutputStream.ComputeBoolSize(8, Sort);
      }
      if (hasStrategy) {
        size += pb::CodedOutputStream.ComputeEnumSize(9, (int) Strategy);
      }
      if (hasTableRows) {
        size += pb::CodedOutputStream.ComputeStringSize(10, TableRows);
      }
      if (hasDebug) {
        size += pb::CodedOutputStream.ComputeBoolSize(11, Debug);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ExecutionRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ExecutionRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ExecutionRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ExecutionRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ExecutionRequest MakeReadOnly() {
      specs_.MakeReadOnly();
      return this;
    }

    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ExecutionRequest prototype) {
      return new Builder(prototype);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ExecutionRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ExecutionRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }

      private bool resultIsReadOnly;
      private ExecutionRequest result;

      private ExecutionRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          ExecutionRequest original = result;
          result = new ExecutionRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }

      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }

      protected override ExecutionRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }

      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }

      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }

      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gauge.Messages.ExecutionRequest.Descriptor; }
      }

      public override ExecutionRequest DefaultInstanceForType {
        get { return global::Gauge.Messages.ExecutionRequest.DefaultInstance; }
      }

      public override ExecutionRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }

      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ExecutionRequest) {
          return MergeFrom((ExecutionRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }

      public override Builder MergeFrom(ExecutionRequest other) {
        if (other == global::Gauge.Messages.ExecutionRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.specs_.Count != 0) {
          result.specs_.Add(other.specs_);
        }
        if (other.HasTags) {
          Tags = other.Tags;
        }
        if (other.HasWorkingDir) {
          WorkingDir = other.WorkingDir;
        }
        if (other.HasEnv) {
          Env = other.Env;
        }
        if (other.HasLogLevel) {
          LogLevel = other.LogLevel;
        }
        if (other.HasIsParallel) {
          IsParallel = other.IsParallel;
        }
        if (other.HasParallelStreams) {
          ParallelStreams = other.ParallelStreams;
        }
        if (other.HasSort) {
          Sort = other.Sort;
        }
        if (other.HasStrategy) {
          Strategy = other.Strategy;
        }
        if (other.HasTableRows) {
          TableRows = other.TableRows;
        }
        if (other.HasDebug) {
          Debug = other.Debug;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }

      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }

      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_executionRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _executionRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadStringArray(tag, field_name, result.specs_);
              break;
            }
            case 18: {
              result.hasTags = input.ReadString(ref result.tags_);
              break;
            }
            case 26: {
              result.hasWorkingDir = input.ReadString(ref result.workingDir_);
              break;
            }
            case 34: {
              result.hasEnv = input.ReadString(ref result.env_);
              break;
            }
            case 40: {
              object unknown;
              if(input.ReadEnum(ref result.logLevel_, out unknown)) {
                result.hasLogLevel = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(5, (ulong)(int)unknown);
              }
              break;
            }
            case 48: {
              result.hasIsParallel = input.ReadBool(ref result.isParallel_);
              break;
            }
            case 56: {
              result.hasParallelStreams = input.ReadInt32(ref result.parallelStreams_);
              break;
            }
            case 64: {
              result.hasSort = input.ReadBool(ref result.sort_);
              break;
            }
            case 72: {
              object unknown;
              if(input.ReadEnum(ref result.strategy_, out unknown)) {
                result.hasStrategy = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(9, (ulong)(int)unknown);
              }
              break;
            }
            case 82: {
              result.hasTableRows = input.ReadString(ref result.tableRows_);
              break;
            }
            case 88: {
              result.hasDebug = input.ReadBool(ref result.debug_);
              break;
            }
          }
        }

        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }


      public pbc::IPopsicleList<string> SpecsList {
        get { return PrepareBuilder().specs_; }
      }
      public int SpecsCount {
        get { return result.SpecsCount; }
      }
      public string GetSpecs(int index) {
        return result.GetSpecs(index);
      }
      public Builder SetSpecs(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.specs_[index] = value;
        return this;
      }
      public Builder AddSpecs(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.specs_.Add(value);
        return this;
      }
      public Builder AddRangeSpecs(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.specs_.Add(values);
        return this;
      }
      public Builder ClearSpecs() {
        PrepareBuilder();
        result.specs_.Clear();
        return this;
      }

      public bool HasTags {
        get { return result.hasTags; }
      }
      public string Tags {
        get { return result.Tags; }
        set { SetTags(value); }
      }
      public Builder SetTags(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTags = true;
        result.tags_ = value;
        return this;
      }
      public Builder ClearTags() {
        PrepareBuilder();
        result.hasTags = false;
        result.tags_ = "";
        return this;
      }

      public bool HasWorkingDir {
        get { return result.hasWorkingDir; }
      }
      public string WorkingDir {
        get { return result.WorkingDir; }
        set { SetWorkingDir(value); }
      }
      public Builder SetWorkingDir(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWorkingDir = true;
        result.workingDir_ = value;
        return this;
      }
      public Builder ClearWorkingDir() {
        PrepareBuilder();
        result.hasWorkingDir = false;
        result.workingDir_ = "";
        return this;
      }

      public bool HasEnv {
        get { return result.hasEnv; }
      }
      public string Env {
        get { return result.Env; }
        set { SetEnv(value); }
      }
      public Builder SetEnv(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEnv = true;
        result.env_ = value;
        return this;
      }
      public Builder ClearEnv() {
        PrepareBuilder();
        result.hasEnv = false;
        result.env_ = "";
        return this;
      }

      public bool HasLogLevel {
       get { return result.hasLogLevel; }
      }
      public global::Gauge.Messages.ExecutionRequest.Types.LogLevel LogLevel {
        get { return result.LogLevel; }
        set { SetLogLevel(value); }
      }
      public Builder SetLogLevel(global::Gauge.Messages.ExecutionRequest.Types.LogLevel value) {
        PrepareBuilder();
        result.hasLogLevel = true;
        result.logLevel_ = value;
        return this;
      }
      public Builder ClearLogLevel() {
        PrepareBuilder();
        result.hasLogLevel = false;
        result.logLevel_ = global::Gauge.Messages.ExecutionRequest.Types.LogLevel.INFO;
        return this;
      }

      public bool HasIsParallel {
        get { return result.hasIsParallel; }
      }
      public bool IsParallel {
        get { return result.IsParallel; }
        set { SetIsParallel(value); }
      }
      public Builder SetIsParallel(bool value) {
        PrepareBuilder();
        result.hasIsParallel = true;
        result.isParallel_ = value;
        return this;
      }
      public Builder ClearIsParallel() {
        PrepareBuilder();
        result.hasIsParallel = false;
        result.isParallel_ = false;
        return this;
      }

      public bool HasParallelStreams {
        get { return result.hasParallelStreams; }
      }
      public int ParallelStreams {
        get { return result.ParallelStreams; }
        set { SetParallelStreams(value); }
      }
      public Builder SetParallelStreams(int value) {
        PrepareBuilder();
        result.hasParallelStreams = true;
        result.parallelStreams_ = value;
        return this;
      }
      public Builder ClearParallelStreams() {
        PrepareBuilder();
        result.hasParallelStreams = false;
        result.parallelStreams_ = 0;
        return this;
      }

      public bool HasSort {
        get { return result.hasSort; }
      }
      public bool Sort {
        get { return result.Sort; }
        set { SetSort(value); }
      }
      public Builder SetSort(bool value) {
        PrepareBuilder();
        result.hasSort = true;
        result.sort_ = value;
        return this;
      }
      public Builder ClearSort() {
        PrepareBuilder();
        result.hasSort = false;
        result.sort_ = false;
        return this;
      }

      public bool HasStrategy {
       get { return result.hasStrategy; }
      }
      public global::Gauge.Messages.ExecutionRequest.Types.Strategy Strategy {
        get { return result.Strategy; }
        set { SetStrategy(value); }
      }
      public Builder SetStrategy(global::Gauge.Messages.ExecutionRequest.Types.Strategy value) {
        PrepareBuilder();
        result.hasStrategy = true;
        result.strategy_ = value;
        return this;
      }
      public Builder ClearStrategy() {
        PrepareBuilder();
        result.hasStrategy = false;
        result.strategy_ = global::Gauge.Messages.ExecutionRequest.Types.Strategy.LAZY;
        return this;
      }

      public bool HasTableRows {
        get { return result.hasTableRows; }
      }
      public string TableRows {
        get { return result.TableRows; }
        set { SetTableRows(value); }
      }
      public Builder SetTableRows(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTableRows = true;
        result.tableRows_ = value;
        return this;
      }
      public Builder ClearTableRows() {
        PrepareBuilder();
        result.hasTableRows = false;
        result.tableRows_ = "";
        return this;
      }

      public bool HasDebug {
        get { return result.hasDebug; }
      }
      public bool Debug {
        get { return result.Debug; }
        set { SetDebug(value); }
      }
      public Builder SetDebug(bool value) {
        PrepareBuilder();
        result.hasDebug = true;
        result.debug_ = value;
        return this;
      }
      public Builder ClearDebug() {
        PrepareBuilder();
        result.hasDebug = false;
        result.debug_ = false;
        return this;
      }
    }
    static ExecutionRequest() {
      object.ReferenceEquals(global::Gauge.Messages.ApiV2.Descriptor, null);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Result : pb::GeneratedMessage<Result, Result.Builder> {
    private Result() { }
    private static readonly Result defaultInstance = new Result().MakeReadOnly();
    private static readonly string[] _resultFieldNames = new string[] { "afterHookFailure", "beforeHookFailure", "errors", "executionTime", "status", "stdout", "tableRowNumber" };
    private static readonly uint[] _resultFieldTags = new uint[] { 50, 42, 18, 24, 8, 34, 56 };
    public static Result DefaultInstance {
      get { return defaultInstance; }
    }

    public override Result DefaultInstanceForType {
      get { return DefaultInstance; }
    }

    protected override Result ThisMessage {
      get { return this; }
    }

    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_Result__Descriptor; }
    }

    protected override pb::FieldAccess.FieldAccessorTable<Result, Result.Builder> InternalFieldAccessors {
      get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_Result__FieldAccessorTable; }
    }

    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Status {
        PASSED = 0,
        FAILED = 1,
        SKIPPED = 2,
      }

      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class ExecutionError : pb::GeneratedMessage<ExecutionError, ExecutionError.Builder> {
        private ExecutionError() { }
        private static readonly ExecutionError defaultInstance = new ExecutionError().MakeReadOnly();
        private static readonly string[] _executionErrorFieldNames = new string[] { "errorMessage", "screenshot", "stackTrace" };
        private static readonly uint[] _executionErrorFieldTags = new uint[] { 10, 26, 18 };
        public static ExecutionError DefaultInstance {
          get { return defaultInstance; }
        }

        public override ExecutionError DefaultInstanceForType {
          get { return DefaultInstance; }
        }

        protected override ExecutionError ThisMessage {
          get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor {
          get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_Result_ExecutionError__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<ExecutionError, ExecutionError.Builder> InternalFieldAccessors {
          get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_Result_ExecutionError__FieldAccessorTable; }
        }

        public const int ErrorMessageFieldNumber = 1;
        private bool hasErrorMessage;
        private string errorMessage_ = "";
        public bool HasErrorMessage {
          get { return hasErrorMessage; }
        }
        public string ErrorMessage {
          get { return errorMessage_; }
        }

        public const int StackTraceFieldNumber = 2;
        private bool hasStackTrace;
        private string stackTrace_ = "";
        public bool HasStackTrace {
          get { return hasStackTrace; }
        }
        public string StackTrace {
          get { return stackTrace_; }
        }

        public const int ScreenshotFieldNumber = 3;
        private bool hasScreenshot;
        private pb::ByteString screenshot_ = pb::ByteString.Empty;
        public bool HasScreenshot {
          get { return hasScreenshot; }
        }
        public pb::ByteString Screenshot {
          get { return screenshot_; }
        }

        public override bool IsInitialized {
          get {
            return true;
          }
        }

        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _executionErrorFieldNames;
          if (hasErrorMessage) {
            output.WriteString(1, field_names[0], ErrorMessage);
          }
          if (hasStackTrace) {
            output.WriteString(2, field_names[2], StackTrace);
          }
          if (hasScreenshot) {
            output.WriteBytes(3, field_names[1], Screenshot);
          }
          UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }

        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;

          size = 0;
          if (hasErrorMessage) {
            size += pb::CodedOutputStream.ComputeStringSize(1, ErrorMessage);
          }
          if (hasStackTrace) {
            size += pb::CodedOutputStream.ComputeStringSize(2, StackTrace);
          }
          if (hasScreenshot) {
            size += pb::CodedOutputStream.ComputeBytesSize(3, Screenshot);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
        public static ExecutionError ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ExecutionError ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ExecutionError ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ExecutionError ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ExecutionError ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ExecutionError ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static ExecutionError ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static ExecutionError ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static ExecutionError ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ExecutionError ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private ExecutionError MakeReadOnly() {
          return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(ExecutionError prototype) {
          return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<ExecutionError, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(ExecutionError cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }

          private bool resultIsReadOnly;
          private ExecutionError result;

          private ExecutionError PrepareBuilder() {
            if (resultIsReadOnly) {
              ExecutionError original = result;
              result = new ExecutionError();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }

          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }

          protected override ExecutionError MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }

          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }

          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }

          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::Gauge.Messages.Result.Types.ExecutionError.Descriptor; }
          }

          public override ExecutionError DefaultInstanceForType {
            get { return global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance; }
          }

          public override ExecutionError BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }

          public override Builder MergeFrom(pb::IMessage other) {
            if (other is ExecutionError) {
              return MergeFrom((ExecutionError) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }

          public override Builder MergeFrom(ExecutionError other) {
            if (other == global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasErrorMessage) {
              ErrorMessage = other.ErrorMessage;
            }
            if (other.HasStackTrace) {
              StackTrace = other.StackTrace;
            }
            if (other.HasScreenshot) {
              Screenshot = other.Screenshot;
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }

          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }

          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_executionErrorFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _executionErrorFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasErrorMessage = input.ReadString(ref result.errorMessage_);
                  break;
                }
                case 18: {
                  result.hasStackTrace = input.ReadString(ref result.stackTrace_);
                  break;
                }
                case 26: {
                  result.hasScreenshot = input.ReadBytes(ref result.screenshot_);
                  break;
                }
              }
            }

            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }


          public bool HasErrorMessage {
            get { return result.hasErrorMessage; }
          }
          public string ErrorMessage {
            get { return result.ErrorMessage; }
            set { SetErrorMessage(value); }
          }
          public Builder SetErrorMessage(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasErrorMessage = true;
            result.errorMessage_ = value;
            return this;
          }
          public Builder ClearErrorMessage() {
            PrepareBuilder();
            result.hasErrorMessage = false;
            result.errorMessage_ = "";
            return this;
          }

          public bool HasStackTrace {
            get { return result.hasStackTrace; }
          }
          public string StackTrace {
            get { return result.StackTrace; }
            set { SetStackTrace(value); }
          }
          public Builder SetStackTrace(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasStackTrace = true;
            result.stackTrace_ = value;
            return this;
          }
          public Builder ClearStackTrace() {
            PrepareBuilder();
            result.hasStackTrace = false;
            result.stackTrace_ = "";
            return this;
          }

          public bool HasScreenshot {
            get { return result.hasScreenshot; }
          }
          public pb::ByteString Screenshot {
            get { return result.Screenshot; }
            set { SetScreenshot(value); }
          }
          public Builder SetScreenshot(pb::ByteString value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasScreenshot = true;
            result.screenshot_ = value;
            return this;
          }
          public Builder ClearScreenshot() {
            PrepareBuilder();
            result.hasScreenshot = false;
            result.screenshot_ = pb::ByteString.Empty;
            return this;
          }
        }
        static ExecutionError() {
          object.ReferenceEquals(global::Gauge.Messages.ApiV2.Descriptor, null);
        }
      }

    }
    #endregion

    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private global::Gauge.Messages.Result.Types.Status status_ = global::Gauge.Messages.Result.Types.Status.PASSED;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public global::Gauge.Messages.Result.Types.Status Status {
      get { return status_; }
    }

    public const int ErrorsFieldNumber = 2;
    private pbc::PopsicleList<global::Gauge.Messages.Result.Types.ExecutionError> errors_ = new pbc::PopsicleList<global::Gauge.Messages.Result.Types.ExecutionError>();
    public scg::IList<global::Gauge.Messages.Result.Types.ExecutionError> ErrorsList {
      get { return errors_; }
    }
    public int ErrorsCount {
      get { return errors_.Count; }
    }
    public global::Gauge.Messages.Result.Types.ExecutionError GetErrors(int index) {
      return errors_[index];
    }

    public const int ExecutionTimeFieldNumber = 3;
    private bool hasExecutionTime;
    private long executionTime_;
    public bool HasExecutionTime {
      get { return hasExecutionTime; }
    }
    public long ExecutionTime {
      get { return executionTime_; }
    }

    public const int StdoutFieldNumber = 4;
    private bool hasStdout;
    private string stdout_ = "";
    public bool HasStdout {
      get { return hasStdout; }
    }
    public string Stdout {
      get { return stdout_; }
    }

    public const int BeforeHookFailureFieldNumber = 5;
    private bool hasBeforeHookFailure;
    private global::Gauge.Messages.Result.Types.ExecutionError beforeHookFailure_;
    public bool HasBeforeHookFailure {
      get { return hasBeforeHookFailure; }
    }
    public global::Gauge.Messages.Result.Types.ExecutionError BeforeHookFailure {
      get { return beforeHookFailure_ ?? global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance; }
    }

    public const int AfterHookFailureFieldNumber = 6;
    private bool hasAfterHookFailure;
    private global::Gauge.Messages.Result.Types.ExecutionError afterHookFailure_;
    public bool HasAfterHookFailure {
      get { return hasAfterHookFailure; }
    }
    public global::Gauge.Messages.Result.Types.ExecutionError AfterHookFailure {
      get { return afterHookFailure_ ?? global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance; }
    }

    public const int TableRowNumberFieldNumber = 7;
    private bool hasTableRowNumber;
    private long tableRowNumber_;
    public bool HasTableRowNumber {
      get { return hasTableRowNumber; }
    }
    public long TableRowNumber {
      get { return tableRowNumber_; }
    }

    public override bool IsInitialized {
      get {
        return true;
      }
    }

    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _resultFieldNames;
      if (hasStatus) {
        output.WriteEnum(1, field_names[4], (int) Status, Status);
      }
      if (errors_.Count > 0) {
        output.WriteMessageArray(2, field_names[2], errors_);
      }
      if (hasExecutionTime) {
        output.WriteInt64(3, field_names[3], ExecutionTime);
      }
      if (hasStdout) {
        output.WriteString(4, field_names[5], Stdout);
      }
      if (hasBeforeHookFailure) {
        output.WriteMessage(5, field_names[1], BeforeHookFailure);
      }
      if (hasAfterHookFailure) {
        output.WriteMessage(6, field_names[0], AfterHookFailure);
      }
      if (hasTableRowNumber) {
        output.WriteInt64(7, field_names[6], TableRowNumber);
      }
      UnknownFields.WriteTo(output);
    }

    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }

    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (hasStatus) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Status);
      }
      foreach (global::Gauge.Messages.Result.Types.ExecutionError element in ErrorsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasExecutionTime) {
        size += pb::CodedOutputStream.ComputeInt64Size(3, ExecutionTime);
      }
      if (hasStdout) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Stdout);
      }
      if (hasBeforeHookFailure) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, BeforeHookFailure);
      }
      if (hasAfterHookFailure) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, AfterHookFailure);
      }
      if (hasTableRowNumber) {
        size += pb::CodedOutputStream.ComputeInt64Size(7, TableRowNumber);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Result ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Result ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Result ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Result ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Result ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Result ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Result ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Result ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Result ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Result ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Result MakeReadOnly() {
      errors_.MakeReadOnly();
      return this;
    }

    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Result prototype) {
      return new Builder(prototype);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Result, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Result cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }

      private bool resultIsReadOnly;
      private Result result;

      private Result PrepareBuilder() {
        if (resultIsReadOnly) {
          Result original = result;
          result = new Result();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }

      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }

      protected override Result MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }

      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }

      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }

      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gauge.Messages.Result.Descriptor; }
      }

      public override Result DefaultInstanceForType {
        get { return global::Gauge.Messages.Result.DefaultInstance; }
      }

      public override Result BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }

      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Result) {
          return MergeFrom((Result) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }

      public override Builder MergeFrom(Result other) {
        if (other == global::Gauge.Messages.Result.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.errors_.Count != 0) {
          result.errors_.Add(other.errors_);
        }
        if (other.HasExecutionTime) {
          ExecutionTime = other.ExecutionTime;
        }
        if (other.HasStdout) {
          Stdout = other.Stdout;
        }
        if (other.HasBeforeHookFailure) {
          MergeBeforeHookFailure(other.BeforeHookFailure);
        }
        if (other.HasAfterHookFailure) {
          MergeAfterHookFailure(other.AfterHookFailure);
        }
        if (other.HasTableRowNumber) {
          TableRowNumber = other.TableRowNumber;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }

      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }

      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_resultFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _resultFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.status_, out unknown)) {
                result.hasStatus = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.errors_, global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance, extensionRegistry);
              break;
            }
            case 24: {
              result.hasExecutionTime = input.ReadInt64(ref result.executionTime_);
              break;
            }
            case 34: {
              result.hasStdout = input.ReadString(ref result.stdout_);
              break;
            }
            case 42: {
              global::Gauge.Messages.Result.Types.ExecutionError.Builder subBuilder = global::Gauge.Messages.Result.Types.ExecutionError.CreateBuilder();
              if (result.hasBeforeHookFailure) {
                subBuilder.MergeFrom(BeforeHookFailure);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BeforeHookFailure = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::Gauge.Messages.Result.Types.ExecutionError.Builder subBuilder = global::Gauge.Messages.Result.Types.ExecutionError.CreateBuilder();
              if (result.hasAfterHookFailure) {
                subBuilder.MergeFrom(AfterHookFailure);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              AfterHookFailure = subBuilder.BuildPartial();
              break;
            }
            case 56: {
              result.hasTableRowNumber = input.ReadInt64(ref result.tableRowNumber_);
              break;
            }
          }
        }

        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }


      public bool HasStatus {
       get { return result.hasStatus; }
      }
      public global::Gauge.Messages.Result.Types.Status Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(global::Gauge.Messages.Result.Types.Status value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = global::Gauge.Messages.Result.Types.Status.PASSED;
        return this;
      }

      public pbc::IPopsicleList<global::Gauge.Messages.Result.Types.ExecutionError> ErrorsList {
        get { return PrepareBuilder().errors_; }
      }
      public int ErrorsCount {
        get { return result.ErrorsCount; }
      }
      public global::Gauge.Messages.Result.Types.ExecutionError GetErrors(int index) {
        return result.GetErrors(index);
      }
      public Builder SetErrors(int index, global::Gauge.Messages.Result.Types.ExecutionError value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.errors_[index] = value;
        return this;
      }
      public Builder SetErrors(int index, global::Gauge.Messages.Result.Types.ExecutionError.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.errors_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddErrors(global::Gauge.Messages.Result.Types.ExecutionError value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.errors_.Add(value);
        return this;
      }
      public Builder AddErrors(global::Gauge.Messages.Result.Types.ExecutionError.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.errors_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeErrors(scg::IEnumerable<global::Gauge.Messages.Result.Types.ExecutionError> values) {
        PrepareBuilder();
        result.errors_.Add(values);
        return this;
      }
      public Builder ClearErrors() {
        PrepareBuilder();
        result.errors_.Clear();
        return this;
      }

      public bool HasExecutionTime {
        get { return result.hasExecutionTime; }
      }
      public long ExecutionTime {
        get { return result.ExecutionTime; }
        set { SetExecutionTime(value); }
      }
      public Builder SetExecutionTime(long value) {
        PrepareBuilder();
        result.hasExecutionTime = true;
        result.executionTime_ = value;
        return this;
      }
      public Builder ClearExecutionTime() {
        PrepareBuilder();
        result.hasExecutionTime = false;
        result.executionTime_ = 0L;
        return this;
      }

      public bool HasStdout {
        get { return result.hasStdout; }
      }
      public string Stdout {
        get { return result.Stdout; }
        set { SetStdout(value); }
      }
      public Builder SetStdout(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasStdout = true;
        result.stdout_ = value;
        return this;
      }
      public Builder ClearStdout() {
        PrepareBuilder();
        result.hasStdout = false;
        result.stdout_ = "";
        return this;
      }

      public bool HasBeforeHookFailure {
       get { return result.hasBeforeHookFailure; }
      }
      public global::Gauge.Messages.Result.Types.ExecutionError BeforeHookFailure {
        get { return result.BeforeHookFailure; }
        set { SetBeforeHookFailure(value); }
      }
      public Builder SetBeforeHookFailure(global::Gauge.Messages.Result.Types.ExecutionError value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBeforeHookFailure = true;
        result.beforeHookFailure_ = value;
        return this;
      }
      public Builder SetBeforeHookFailure(global::Gauge.Messages.Result.Types.ExecutionError.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBeforeHookFailure = true;
        result.beforeHookFailure_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBeforeHookFailure(global::Gauge.Messages.Result.Types.ExecutionError value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBeforeHookFailure &&
            result.beforeHookFailure_ != global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance) {
            result.beforeHookFailure_ = global::Gauge.Messages.Result.Types.ExecutionError.CreateBuilder(result.beforeHookFailure_).MergeFrom(value).BuildPartial();
        } else {
          result.beforeHookFailure_ = value;
        }
        result.hasBeforeHookFailure = true;
        return this;
      }
      public Builder ClearBeforeHookFailure() {
        PrepareBuilder();
        result.hasBeforeHookFailure = false;
        result.beforeHookFailure_ = null;
        return this;
      }

      public bool HasAfterHookFailure {
       get { return result.hasAfterHookFailure; }
      }
      public global::Gauge.Messages.Result.Types.ExecutionError AfterHookFailure {
        get { return result.AfterHookFailure; }
        set { SetAfterHookFailure(value); }
      }
      public Builder SetAfterHookFailure(global::Gauge.Messages.Result.Types.ExecutionError value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAfterHookFailure = true;
        result.afterHookFailure_ = value;
        return this;
      }
      public Builder SetAfterHookFailure(global::Gauge.Messages.Result.Types.ExecutionError.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAfterHookFailure = true;
        result.afterHookFailure_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAfterHookFailure(global::Gauge.Messages.Result.Types.ExecutionError value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAfterHookFailure &&
            result.afterHookFailure_ != global::Gauge.Messages.Result.Types.ExecutionError.DefaultInstance) {
            result.afterHookFailure_ = global::Gauge.Messages.Result.Types.ExecutionError.CreateBuilder(result.afterHookFailure_).MergeFrom(value).BuildPartial();
        } else {
          result.afterHookFailure_ = value;
        }
        result.hasAfterHookFailure = true;
        return this;
      }
      public Builder ClearAfterHookFailure() {
        PrepareBuilder();
        result.hasAfterHookFailure = false;
        result.afterHookFailure_ = null;
        return this;
      }

      public bool HasTableRowNumber {
        get { return result.hasTableRowNumber; }
      }
      public long TableRowNumber {
        get { return result.TableRowNumber; }
        set { SetTableRowNumber(value); }
      }
      public Builder SetTableRowNumber(long value) {
        PrepareBuilder();
        result.hasTableRowNumber = true;
        result.tableRowNumber_ = value;
        return this;
      }
      public Builder ClearTableRowNumber() {
        PrepareBuilder();
        result.hasTableRowNumber = false;
        result.tableRowNumber_ = 0L;
        return this;
      }
    }
    static Result() {
      object.ReferenceEquals(global::Gauge.Messages.ApiV2.Descriptor, null);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ExecutionResponse : pb::GeneratedMessage<ExecutionResponse, ExecutionResponse.Builder> {
    private ExecutionResponse() { }
    private static readonly ExecutionResponse defaultInstance = new ExecutionResponse().MakeReadOnly();
    private static readonly string[] _executionResponseFieldNames = new string[] { "ID", "result", "type" };
    private static readonly uint[] _executionResponseFieldTags = new uint[] { 18, 26, 8 };
    public static ExecutionResponse DefaultInstance {
      get { return defaultInstance; }
    }

    public override ExecutionResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }

    protected override ExecutionResponse ThisMessage {
      get { return this; }
    }

    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_ExecutionResponse__Descriptor; }
    }

    protected override pb::FieldAccess.FieldAccessorTable<ExecutionResponse, ExecutionResponse.Builder> InternalFieldAccessors {
      get { return global::Gauge.Messages.ApiV2.internal__static_gauge_messages_ExecutionResponse__FieldAccessorTable; }
    }

    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Type {
        SuiteStart = 0,
        SpecStart = 1,
        ScenarioStart = 2,
        ScenarioEnd = 3,
        SpecEnd = 4,
        SuiteEnd = 5,
        ErrorResult = 6,
      }

    }
    #endregion

    public const int TypeFieldNumber = 1;
    private bool hasType;
    private global::Gauge.Messages.ExecutionResponse.Types.Type type_ = global::Gauge.Messages.ExecutionResponse.Types.Type.SuiteStart;
    public bool HasType {
      get { return hasType; }
    }
    public global::Gauge.Messages.ExecutionResponse.Types.Type Type {
      get { return type_; }
    }

    public const int IDFieldNumber = 2;
    private bool hasID;
    private string iD_ = "";
    public bool HasID {
      get { return hasID; }
    }
    public string ID {
      get { return iD_; }
    }

    public const int ResultFieldNumber = 3;
    private bool hasResult;
    private global::Gauge.Messages.Result result_;
    public bool HasResult {
      get { return hasResult; }
    }
    public global::Gauge.Messages.Result Result {
      get { return result_ ?? global::Gauge.Messages.Result.DefaultInstance; }
    }

    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        return true;
      }
    }

    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _executionResponseFieldNames;
      if (hasType) {
        output.WriteEnum(1, field_names[2], (int) Type, Type);
      }
      if (hasID) {
        output.WriteString(2, field_names[0], ID);
      }
      if (hasResult) {
        output.WriteMessage(3, field_names[1], Result);
      }
      UnknownFields.WriteTo(output);
    }

    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }

    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (hasType) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
      }
      if (hasID) {
        size += pb::CodedOutputStream.ComputeStringSize(2, ID);
      }
      if (hasResult) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Result);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ExecutionResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ExecutionResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ExecutionResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ExecutionResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ExecutionResponse MakeReadOnly() {
      return this;
    }

    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ExecutionResponse prototype) {
      return new Builder(prototype);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ExecutionResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ExecutionResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }

      private bool resultIsReadOnly;
      private ExecutionResponse result;

      private ExecutionResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          ExecutionResponse original = result;
          result = new ExecutionResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }

      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }

      protected override ExecutionResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }

      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }

      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }

      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gauge.Messages.ExecutionResponse.Descriptor; }
      }

      public override ExecutionResponse DefaultInstanceForType {
        get { return global::Gauge.Messages.ExecutionResponse.DefaultInstance; }
      }

      public override ExecutionResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }

      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ExecutionResponse) {
          return MergeFrom((ExecutionResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }

      public override Builder MergeFrom(ExecutionResponse other) {
        if (other == global::Gauge.Messages.ExecutionResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasID) {
          ID = other.ID;
        }
        if (other.HasResult) {
          MergeResult(other.Result);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }

      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }

      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_executionResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _executionResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              result.hasID = input.ReadString(ref result.iD_);
              break;
            }
            case 26: {
              global::Gauge.Messages.Result.Builder subBuilder = global::Gauge.Messages.Result.CreateBuilder();
              if (result.hasResult) {
                subBuilder.MergeFrom(Result);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Result = subBuilder.BuildPartial();
              break;
            }
          }
        }

        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }


      public bool HasType {
       get { return result.hasType; }
      }
      public global::Gauge.Messages.ExecutionResponse.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::Gauge.Messages.ExecutionResponse.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::Gauge.Messages.ExecutionResponse.Types.Type.SuiteStart;
        return this;
      }

      public bool HasID {
        get { return result.hasID; }
      }
      public string ID {
        get { return result.ID; }
        set { SetID(value); }
      }
      public Builder SetID(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasID = true;
        result.iD_ = value;
        return this;
      }
      public Builder ClearID() {
        PrepareBuilder();
        result.hasID = false;
        result.iD_ = "";
        return this;
      }

      public bool HasResult {
       get { return result.hasResult; }
      }
      public global::Gauge.Messages.Result Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(global::Gauge.Messages.Result value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder SetResult(global::Gauge.Messages.Result.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = builderForValue.Build();
        return this;
      }
      public Builder MergeResult(global::Gauge.Messages.Result value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasResult &&
            result.result_ != global::Gauge.Messages.Result.DefaultInstance) {
            result.result_ = global::Gauge.Messages.Result.CreateBuilder(result.result_).MergeFrom(value).BuildPartial();
        } else {
          result.result_ = value;
        }
        result.hasResult = true;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = null;
        return this;
      }
    }
    static ExecutionResponse() {
      object.ReferenceEquals(global::Gauge.Messages.ApiV2.Descriptor, null);
    }
  }

  #endregion

}

#endregion Designer generated code
